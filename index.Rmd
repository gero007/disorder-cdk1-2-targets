---
title: "Disorder in Cdk1/2 targets"
output:
  html_document:
    df_print: paged
     
    
---
```{r setup,echo=FALSE,message=FALSE,warning=FALSE,prompt=FALSE}
library(jsonlite)
library(readr)

# yeastDiso is a complex database from MobiDB Saccharomyces cerevisiae. 

yeastDiso<-stream_in(con = file("~/projects/cdk1_cyclinB1/phase_separation/disorder/disorder_UP000002311.mjson"),verbose = F)
yeastDiso$mobidb_consensus <- yeastDiso$mobidb_consensus$disorder
colnames(yeastDiso)[5] <- "disorder"

CDK1targetSacCer <- read_delim("~/projects/cdk1_cyclinB1/phase_separation/disorder/CDK1targetSacCer.csv", 
                          "\t", quote = "\\\"", escape_double = FALSE, 
                          col_types = cols(X1 = col_skip(), input = col_skip(), 
                          `yourlist:M201907046746803381A1F0E0DB47453E0216320D4B0BD1N` = col_skip()), 
                          trim_ws = TRUE)

# Now the comumn "disorder" is a unnamed list with a complex structure for each row of the data frame

```

# MobiDB
  
The [MobiDB](http://mobidb.bio.unipd.it) database of protein disorder and mobility annotations has been significantly updated and upgraded since its last major renewal in 2014. Several curated datasets for intrinsic disorder and folding upon binding have been integrated from specialized databases. The indirect evidence has also been expanded to better capture information available in the PDB, such as high temperature residues in X-ray structures and overall conformational diversity.  
The database is organize in three layers containing data of different nature: Disorder, Linear Interacting Peptides (LIPs) and Dynamic structure. The "Disorder" database bears data about protein regions without a defined tri-dimensional structure. The "LIPs" layer contains information about regions or residues that interact with other proteins or DNA/RNA preserving a linear (disordered) structure. At last, the data hosted in the "Dynamic structure" layer describes the propensity of a residue to assume a specific secondary structure conformation. When extracted from chemical shifts can be interpreted as a measure of the secondary structure populations in solution.
Each one of three layers features three quality levels of annotation from high to low quality (Fig. 1), presenting different coverage of the universe of known proteins.
  
  
![Fig. 1: MobiDB confidence vs. coverage. DB refers to manually curated annotations from external databases. Indirect consist in annotations derived/calculated information from experimental data, i.e. PDB structures and/or chemical shifts. Predicted annotations are annotations made using purely bioinformatic tools](/home/gdubra/projects/cdk1_cyclinB1/phase_separation/disorder/images/mobiDB_confVScoverage.png)

## Disorder  
  
As a first aproach I explored the Disorder database from Mobidb for the whole annotated proteome of saccharomyces cerevisiae. The data set comprehend information of disordered region over 6721 proteins. As explained before, each entry could have annotations of disorder in three diferent levels (DB, indirect, Predicted) which, at the same time, collect information from several sources in order to arrive to a consensus of the regions with or without a defined tri-demensional structure. I this way, the consensus of each level annotates the regions as structured "S", Disordered "D" or conflict "C", when there are more than one source of information over a protein region that contradict each other.  

```{r all data summary ,echo=FALSE,message=FALSE,warning=FALSE}

npredictors=0
nmobidblite=0
nsimple=0
#methods: mobidb-lite, simple
for (i in 1:nrow(yeastDiso)) {
  if(!is.null(yeastDiso[i,5]$predictors[[1]])){
    npredictors=npredictors+1
    }
  if( "mobidb-lite" %in% yeastDiso[i,5]$predictors[[1]]$method){
    nmobidblite=nmobidblite+1
    }
  if( "simple" %in% yeastDiso[i,5]$predictors[[1]]$method){
    nsimple=nsimple+1
    }  
  }


#methods: full bfactor missing_residues mobile
nderived=0
nfull=0
nbfactor=0
nmissing_residues=0
nmobile=0

for (i in 1:nrow(yeastDiso)) {
  if(!is.null(yeastDiso[i,5]$derived[[1]])){
    nderived=nderived+1
  }
  if( "full" %in% yeastDiso[i,5]$derived[[1]]$method){
    nfull=nfull+1
  }
  if( "bfactor" %in% yeastDiso[i,5]$derived[[1]]$method){
    nbfactor=nbfactor+1
  }
  if( "missing_residues" %in% yeastDiso[i,5]$derived[[1]]$method){
    nmissing_residues=nmissing_residues+1
  }
  if( "mobile" %in% yeastDiso[i,5]$derived[[1]]$method){
    nmobile=nmobile+1
  }
}
#methods: full
ndb=0
for (i in 1:nrow(yeastDiso)) {
  if(!is.null(yeastDiso[i,5]$db[[1]])){
    ndb=ndb+1
    }
  }
```

In order to understand the data the first analysis to do is to evaluate the coverage of the different levels of annotations in the database. In this way we can select a level or a combination of them for assigning the disorder regions to each protein considering the comprimise between the quality of the annotation and the coverage of the protein set of interest.  
DB is the level with less coverage, since its annotations are manually curated, and it has `r ndb` entries covering a `r round((ndb/nrow(yeastDiso))*100,2)`% of the whole proteome. The data annotated in the "Derived" level holds `r nderived` entries and this covers `r round((nderived/nrow(yeastDiso))*100,2)`% of available proteins for S. cerevisiae. Since the predictors do not have any limitations on wich proteins could this methods be applied, they cover the entire protein set.
```{r set disorder metrics columns,echo=FALSE,message=FALSE,warning=FALSE}

#All the anotations in the prediction are for disordered regions
predDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  mat<-yeastDiso$disorder$predictors[[i]]$regions[[1]]
  #calculate the number of disoredered AAs
  nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  proteinLength <- nchar(yeastDiso$sequence[i])
  predDisoPercAll <- c(predDisoPercAll,(nDiso/proteinLength)*100)
}
yeastDiso$predDisoPercAll <- predDisoPercAll

#mobidb-lite for comparing with the simple
predLiteDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  liteIndex<-which(yeastDiso$disorder$predictors[[i]]$method=="mobidb-lite")
  if (length(liteIndex)!=0) {
    mat<-yeastDiso$disorder$predictors[[i]]$regions[[liteIndex]]
    if (class(mat)=="matrix") {
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
      mat<-matrix(mat[mat[,3]=="D",],ncol=3)
      #calculate the number of disoredered AAs
      nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      proteinLength <- nchar(yeastDiso$sequence[i])
      predLiteDisoPercAll <- c(predLiteDisoPercAll,(nDiso/proteinLength)*100)      
    } else {predLiteDisoPercAll <- c(predLiteDisoPercAll,0)}

  } else {
    predLiteDisoPercAll <- c(predLiteDisoPercAll,NA)
  }

}
yeastDiso$predLiteDisoPercAll <- predLiteDisoPercAll

#For the derived methods (full -> the third matrix) the anotations could be Disorder, Structure or Conflict
derivedDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  if (!is.null(yeastDiso$disorder$derived[[i]])) {
    fullIndex<-which(yeastDiso$disorder$derived[[i]]$method=="full")
    mat<-yeastDiso$disorder$derived[[i]]$regions[[fullIndex]]
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
    mat<-matrix(mat[mat[,3]=="D",],ncol=3)
    #calculate the number of disoredered AAs
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(yeastDiso$sequence[i])
    derivedDisoPercAll <- c(derivedDisoPercAll,(nDiso/proteinLength)*100)
  } else {
    derivedDisoPercAll <- c(derivedDisoPercAll,NA)
  }

}
yeastDiso$derivedDisoPercAll <- derivedDisoPercAll

#For the db curated assigments (full -> the only matrix) the anotations could be Disorder, Structure or Conflict
dbDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  if (!is.null(yeastDiso$disorder$db[[i]])) {
    fullIndex<-which(yeastDiso$disorder$db[[i]]$method=="full")
    mat<-yeastDiso$disorder$db[[i]]$regions[[fullIndex]]
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
    mat<-matrix(mat[mat[,3]=="D",],ncol=3)
    #calculate the number of disoredered AAs
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(yeastDiso$sequence[i])
    dbDisoPercAll <- c(dbDisoPercAll,(nDiso/proteinLength)*100)
  } else {
    dbDisoPercAll <- c(dbDisoPercAll,NA)
  }
}
yeastDiso$dbDisoPercAll <- dbDisoPercAll
```
Once we have stablished the disorder regions for each protein it is useful to have a metric describing the global disorder status for each entry in order to summarise in one number the degree of disorder and to being able to make comparisons at the protein level. The percentage (or ratio) of disorder aminoacids over the total number of aminoacids of a protein constitute the most direct metric for this means, providing one value that we can assign to each proteins describing its state of disorder.  

```{r cdk1 targets summary,echo=FALSE,message=FALSE,warning=FALSE}

# _____________________________________________________________

#The row 294 cannot be mapped with the uniprot, I will remove it from CDK1targetsSacCer and yeastDisoCDK1target

yeastDisoCDK1target<-yeastDiso[match(CDK1targetSacCer$Entry,yeastDiso$acc),]
CDK1targetSacCer<-CDK1targetSacCer[-294,]
yeastDisoCDK1target <- yeastDisoCDK1target[-294,]



npredictorsCDK=0
nmobidbliteCDK=0
nsimpleCDK=0
#methods: mobidb-lite, simple
for (i in 1:nrow(yeastDisoCDK1target)) {
  if(!is.null(yeastDisoCDK1target[i,5]$predictors[[1]])){
    npredictorsCDK=npredictorsCDK+1
    }
  if( "mobidb-lite" %in% yeastDisoCDK1target[i,5]$predictors[[1]]$method){
    nmobidbliteCDK=nmobidbliteCDK+1
    }
  if( "simple" %in% yeastDisoCDK1target[i,5]$predictors[[1]]$method){
    nsimpleCDK=nsimpleCDK+1
    }  
  }


#methods: full bfactor missing_residues mobile
nderivedCDK=0
nfullCDK=0
nbfactorCDK=0
nmissing_residuesCDK=0
nmobileCDK=0

for (i in 1:nrow(yeastDisoCDK1target)) {
  if(!is.null(yeastDisoCDK1target[i,5]$derived[[1]])){
    nderivedCDK=nderivedCDK+1
  }
  if( "full" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nfullCDK=nfullCDK+1
  }
  if( "bfactor" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nbfactorCDK=nbfactorCDK+1
  }
  if( "missing_residues" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nmissing_residuesCDK=nmissing_residuesCDK+1
  }
  if( "mobile" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nmobileCDK=nmobileCDK+1
  }
}
#methods: full
ndbCDK=0
for (i in 1:nrow(yeastDisoCDK1target)) {
  if(!is.null(yeastDisoCDK1target[i,5]$db[[1]])){
    ndbCDK=ndbCDK+1
    }
  }
```


```{r explore,echo=FALSE,message=FALSE,warning=FALSE}

predDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  mat<-yeastDiso$disorder$predictors[[i]]$regions[[1]]
  #calculate the number of disoredered AAs
  nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  proteinLength <- nchar(yeastDiso$sequence[i])
  predDisoPercAll <- c(predDisoPercAll,(nDiso/proteinLength)*100)
}
hist(predDisoPercAll,breaks = 100)





predDisoPercCDK1target <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  mat<-yeastDisoCDK1target$disorder$predictors[[i]]$regions[[1]]
  #calculate the number of disoredered AAs
  nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
  predDisoPercCDK1target <- c(predDisoPercCDK1target,(nDiso/proteinLength)*100)
}
hist(predDisoPercCDK1target,breaks = 100)


CDK1targetSacCer$percDiso_predicted <- yeastDisoCDK1target$predDisoPerc


```

