---
title: "Disorder in Cdk1/2 targets"
output:
  html_document:
    df_print: paged
    fig_caption: yes
  pdf_document: default
params:
  d: !r Sys.Date()
bibliography: references.bib
---
updated: `r params$d`  

```{r setup,echo=FALSE,message=FALSE,warning=FALSE,prompt=FALSE}
library(jsonlite)
library(readr)
library(ggplot2)
library(GGally)
library(vcd)
library(kableExtra)
library(ggpubr)

# yeastDiso is a complex database from MobiDB Saccharomyces cerevisiae. 

yeastDiso<-stream_in(con = file("~/projects/cdk1_cyclinB1/phase_separation/disorder/disorder_UP000002311.mjson"),verbose = F)
yeastDiso$mobidb_consensus <- yeastDiso$mobidb_consensus$disorder
colnames(yeastDiso)[5] <- "disorder"

CDK1targetSacCer <- read_delim("~/projects/cdk1_cyclinB1/phase_separation/disorder/CDK1targetSacCer.csv", 
                          "\t", quote = "\\\"", escape_double = FALSE, 
                          col_types = cols(X1 = col_skip(), input = col_skip(), 
                          `yourlist:M201907046746803381A1F0E0DB47453E0216320D4B0BD1N` = col_skip()), 
                          trim_ws = TRUE)

# Now the comumn "disorder" is a unnamed list with a complex structure for each row of the data frame




```

# MobiDB
  
The [MobiDB](http://mobidb.bio.unipd.it) database of protein disorder and mobility annotations has been significantly updated and upgraded since its last major renewal in 2014. Several curated datasets for intrinsic disorder and folding upon binding have been integrated from specialized databases. The indirect evidence has also been expanded to better capture information available in the PDB, such as high-temperature residues in X-ray structures and overall conformational diversity.  
The database is organized in three layers containing data of different nature: Disorder, Linear Interacting Peptides (LIPs) and Dynamic structure. The "Disorder" database bears data about protein regions without a defined tri-dimensional structure. The "LIPs" layer contains information about regions or residues that interact with other proteins or DNA/RNA preserving a linear (disordered) structure. At last, the data hosted in the "Dynamic structure" layer describes the propensity of a residue to assume a specific secondary structure conformation. When extracted from chemical shifts can be interpreted as a measure of the secondary structure populations in solution.
Each one of three layers features three quality levels of annotation from high to low quality (Fig. 1), presenting different coverage of the universe of known proteins.
  
```{r confidence pyramid ,echo=FALSE,message=FALSE,warning=FALSE,fig.cap="Figure 1: MobiDB confidence vs. coverage. DB refers to manually curated annotations from external databases. Indirect consist in annotations derived/calculated information from experimental data, i.e. PDB structures and/or chemical shifts. Predicted annotations are made using exclusively bioinformatic tools", out.width = "400px"}

knitr::include_graphics("/home/gdubra/projects/cdk1_cyclinB1/phase_separation/disorder/images/mobiDB_confVScoverage.png")

```  


## Disorder  
  
As a first approach, I explored the Disorder database from Mobidb for the whole annotated proteome of Saccharomyces cerevisiae. The data set comprehends the information of disordered region over 6721 proteins. As explained before, each entry could have annotations of disorder in three different levels (DB, indirect, Predicted) which, at the same time, collect information from several sources in order to reach to a consensus of the regions with or without a defined tri-dimensional structure. I this way, the consensus of each level annotates the regions as structured "S", Disordered "D" or conflict "C", when there is more than one source of information over a protein region that contradicts each other.

```{r all data summary ,echo=FALSE,message=FALSE,warning=FALSE}
npredictors=0
nmobidblite=0
nsimple=0
#methods: mobidb-lite, simple
for (i in 1:nrow(yeastDiso)) {
  if(!is.null(yeastDiso[i,5]$predictors[[1]])){
    npredictors=npredictors+1
    }
  if( "mobidb-lite" %in% yeastDiso[i,5]$predictors[[1]]$method){
    nmobidblite=nmobidblite+1
    }
  if( "simple" %in% yeastDiso[i,5]$predictors[[1]]$method){
    nsimple=nsimple+1
    }  
  }


#methods: full bfactor missing_residues mobile
nderived=0
nfull=0
nbfactor=0
nmissing_residues=0
nmobile=0

for (i in 1:nrow(yeastDiso)) {
  if(!is.null(yeastDiso[i,5]$derived[[1]])){
    nderived=nderived+1
  }
  if( "full" %in% yeastDiso[i,5]$derived[[1]]$method){
    nfull=nfull+1
  }
  if( "bfactor" %in% yeastDiso[i,5]$derived[[1]]$method){
    nbfactor=nbfactor+1
  }
  if( "missing_residues" %in% yeastDiso[i,5]$derived[[1]]$method){
    nmissing_residues=nmissing_residues+1
  }
  if( "mobile" %in% yeastDiso[i,5]$derived[[1]]$method){
    nmobile=nmobile+1
  }
}
#methods: full
ndb=0
for (i in 1:nrow(yeastDiso)) {
  if(!is.null(yeastDiso[i,5]$db[[1]])){
    ndb=ndb+1
    }
  }
```

In order to understand the data the first analysis to do is to evaluate the coverage of the different levels of annotations in the database. In this way, we can select a level or a combination of them for assigning the disorder regions to each protein considering the compromise between the quality of the annotation and the coverage of the protein set of interest.  
DB is the level with less coverage, since its annotations are manually curated, and it has **`r ndb`** entries covering a **`r round((ndb/nrow(yeastDiso))*100,2)`%** of the whole proteome. The data annotated in the "Derived" level holds **`r nderived`** entries and this covers **`r round((nderived/nrow(yeastDiso))*100,2)`%** of available proteins for S. cerevisiae. Since the predictors do not have any limitations in terms of which proteins could these methods be applied to, they cover the entire protein set.  
  
| Level      | Method           | N° entries            | Level coverage (%)                            | Method coverage (%)                                 |
|------------|------------------|-----------------------|-----------------------------------------------|-----------------------------------------------------|
| DB         | full             | `r ndb`               | `r round((ndb/ndb)*100,2)`                    | `r round((ndb/nrow(yeastDiso))*100,2)`              |
| Derived    | full             | `r nderived`          | `r round((nderived/nderived)*100,2)`          | `r round((nderived/nrow(yeastDiso))*100,2)`         |
|            | bfactor          | `r nbfactor`          | `r round((nbfactor/nderived)*100,2)`          | `r round((nbfactor/nrow(yeastDiso))*100,2)`         |
|            | missing-residues | `r nmissing_residues` | `r round((nmissing_residues/nderived)*100,2)` | `r round((nmissing_residues/nrow(yeastDiso))*100,2)`|
|            | mobile           | `r nmobile`           | `r round((nmobile/nderived)*100,2)`           | `r round((nmobile/nrow(yeastDiso))*100,2)`          |
| Predictors | simple           | `r nsimple`           | `r round((nsimple/nsimple)*100,2)`            | `r round((nsimple/nrow(yeastDiso))*100,2)`          |
|            | mobidb-lite      | `r nmobidblite`       | `r round((nmobidblite/nsimple)*100,2)`        | `r round((nmobidblite/nrow(yeastDiso))*100,2)`      |
Table 1:  Percent of covered entries by each Level and method of the MobiDB database.  
  
  
### Percentage of disordered aminoacids  
  
  
Once we have established the disorder regions for each protein it is useful to have a metric describing the global disorder status for each entry in order to summarise in one number the degree of disorder and to being able to make comparisons at the protein level. The percentage (or ratio) of disorder amino acids over the total number of amino acids of a protein constitute the most direct metric, providing one value that we can assign to each proteins describing its state of disorder.

```{r set disorder metrics columns,echo=FALSE,message=FALSE,warning=FALSE}

#All the anotations in the prediction are for disordered regions


getPredDiso <- function(df,output){
  predDisoPercAll <- c()
  predStretchDist <- c()
  disoPosList <- list()
  for (i in 1:nrow(df)) {
    mat<-df$disorder$predictors[[i]]$regions[[1]]
    predStretchDist <- c(predStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    #calculate the number of disoredered AAs
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(df$sequence[i])
    predDisoPercAll <- c(predDisoPercAll,(nDiso/proteinLength)*100)
    
    disoPos <-numeric()
    disoPos <-apply(mat, 1, function(x){disoPos<-c(disoPos,x[1]:x[2])
                                   return(disoPos)})
    disoPos <- as.numeric(unlist(disoPos))
    disoPosList[[i]]<-disoPos
  }
if (output=="percentage") {
    return(predDisoPercAll)
  } else if (output=="lenghts") {
    return(predStretchDist)
  } else if (output=="indices") {
    return(disoPosList)
  } else {stop("wrong output specified. Options are 'percentage','lenghts' or 'indices' ")}
}

yeastDiso$predDisoPercAll <- getPredDiso(yeastDiso,output = "percentage")

getPredLiteDiso <- function(df,output){
  predLiteDisoPercAll <- c()
  predLiteStretchDist <- c()
  disoPosList <- list()
  for (i in 1:nrow(df)) {
    liteIndex<-which(df$disorder$predictors[[i]]$method=="mobidb-lite")
    if (length(liteIndex)!=0) {
      mat<-df$disorder$predictors[[i]]$regions[[liteIndex]]
      if (class(mat)=="matrix") {
        predLiteStretchDist <- c(predLiteStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
        #calculate the number of disoredered AAs
        nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
        proteinLength <- nchar(df$sequence[i])
        predLiteDisoPercAll <- c(predLiteDisoPercAll,(nDiso/proteinLength)*100)
        
        disoPos <-numeric()
        disoPos <-apply(mat, 1, function(x){disoPos<-c(disoPos,x[1]:x[2])
                                       return(disoPos)})
        disoPos <- as.numeric(unlist(disoPos))
        disoPosList[[i]]<-disoPos
      } else {predLiteDisoPercAll <- c(predLiteDisoPercAll,0)}
    } else {predLiteDisoPercAll <- c(predLiteDisoPercAll,NA)}
  }
if (output=="percentage") {
    return(predLiteDisoPercAll)
  } else if (output=="lenghts") {
    return(predLiteStretchDist)
  } else if (output=="indices") {
    return(disoPosList)
  } else {stop("wrong output specified. Options are 'percentage','lenghts' or 'indices' ")}
}

#mobidb-lite for comparing with the simple
predLiteStretchDist <- c()
predLiteDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  liteIndex<-which(yeastDiso$disorder$predictors[[i]]$method=="mobidb-lite")
  if (length(liteIndex)!=0) {
    mat<-yeastDiso$disorder$predictors[[i]]$regions[[liteIndex]]
    if (class(mat)=="matrix") {
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
      # mat<-matrix(mat[mat[,3]=="D",],ncol=3)
      predLiteStretchDist <- c(predLiteStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      #calculate the number of disoredered AAs
      nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      proteinLength <- nchar(yeastDiso$sequence[i])
      predLiteDisoPercAll <- c(predLiteDisoPercAll,(nDiso/proteinLength)*100)      
    } else {predLiteDisoPercAll <- c(predLiteDisoPercAll,0)}

  } else {
    predLiteDisoPercAll <- c(predLiteDisoPercAll,NA)
  }

}
yeastDiso$predLiteDisoPercAll <- predLiteDisoPercAll

#For the derived methods (full -> the third matrix) the anotations could be Disorder, Structure or Conflict
derivedStretchDist <- c()
derivedDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  if (!is.null(yeastDiso$disorder$derived[[i]])) {
    fullIndex<-which(yeastDiso$disorder$derived[[i]]$method=="full")
    mat<-yeastDiso$disorder$derived[[i]]$regions[[fullIndex]]
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
    mat<-matrix(mat[mat[,3]=="D",],ncol=3)
    derivedStretchDist <- c(derivedStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    #calculate the number of disoredered AAs
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(yeastDiso$sequence[i])
    derivedDisoPercAll <- c(derivedDisoPercAll,(nDiso/proteinLength)*100)
  } else {
    derivedDisoPercAll <- c(derivedDisoPercAll,NA)
  }

}
yeastDiso$derivedDisoPercAll <- derivedDisoPercAll

#For the db curated assigments (full -> the only matrix) the anotations could be Disorder, Structure or Conflict
dbDisoPercAll <- c()
dbStretchDist <- c()
for (i in 1:nrow(yeastDiso)) {
  if (!is.null(yeastDiso$disorder$db[[i]])) {
    fullIndex<-which(yeastDiso$disorder$db[[i]]$method=="full")
    mat<-yeastDiso$disorder$db[[i]]$regions[[fullIndex]]
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
    mat<-matrix(mat[mat[,3]=="D",],ncol=3)
    #calculate the number of disoredered AAs
    dbStretchDist <- c(dbStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(yeastDiso$sequence[i])
    dbDisoPercAll <- c(dbDisoPercAll,(nDiso/proteinLength)*100)
  } else {
    dbDisoPercAll <- c(dbDisoPercAll,NA)
  }
}
yeastDiso$dbDisoPercAll <- dbDisoPercAll

```

```{r histograms predictors,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 2: Histogram for the disorder percentages estimated by the two predictors"}

ggplot(data = yeastDiso)+geom_histogram(aes(x=predLiteDisoPercAll,fill="MobiDB lite"),bins = 30,alpha=0.5,position = "identity")+geom_histogram(aes(x=predDisoPercAll,fill="Simple"),bins = 30,alpha=0.5,position = "identity") + theme_minimal() + xlab("% of disorder residues") + scale_fill_manual(name = "Predictor", values = c("Simple"="darkorange1","MobiDB lite" = "chartreuse3"))
```
  
  
Both of the predictors featured by the MobiDB database have a notorious discrepancy on the number of residues on which they assign the "Disorder" status. This could be due, in principle, to the differences in their conceptions.  The "Simple" method is basically consensus derived from some of the already established disorder bioinformatic predictors and features region-wise annotations. In contrast, the method called MobiDB lite is, in fact, an *ad hoc* development that not only uses a consensus between these methods but also quantifies the agreement among different predictors, and it is optimized for detecting long intrinsically disordered regions (IDR) and the detection of short regions are filtered out. This could explain why Figure 1 presents a great proportion of proteins without any disorder residue for the MobiDB lite predictor. It is understandable then, that the ratio of the residues detected as intrinsically disorder over the total length of the proteins, by those different methods, are not in agreement and even they seem to be complementary between them.  
  
For the "Derived" and "DB" levels, the identification of IDR has, allegedly, a higher degree of confidence. The comparison the percentage of disorder residues estimated by those levels (Figure 3) and the prediction methods could help to clarify which prediction is the better option if we want to use the percentage of disordered amino acids as metric to evaluate disorder at the protein level.  
  
  
```{r histograms dbANDderived,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 3: Histogram for the disorder percentages estimated for the 'DB' and 'Derived' levels"}

ggplot(data = yeastDiso)+geom_histogram(aes(x=dbDisoPercAll,fill="DB"),bins = 30,alpha=0.5,position = "identity")+geom_histogram(aes(x=derivedDisoPercAll,fill="Derived"),bins = 30,alpha=0.5,position = "identity") + theme_minimal() + xlab("% of disorder residues") + scale_fill_manual(name = "Level", values = c("Derived"="darkgoldenrod1","DB" = "deepskyblue2"))
```
  
The use of the derived data for assigning IDRs seems to present a distribution of the percentage of disorder residues congruent with the MobiDB lite predictor, presenting a considerable proportion of protein not having any disorder residues.

Similar distributions of the percentage of disorder residues, for two different predictors, could be validated if the predictors are assigning similar percentage values to the same proteins. If this is the case, we should be able to find a correlation between the values calculated by different methods. In Figure 4, pairwise comparisons for both of the prediction methods and the Derived and DB annotations are shown, together with the density distributions and the corresponding correlation coefficients. Since we are interested in elucidating how CDK phosphorylation could be involved in the disorder states of its targets, another level of complexity is added to this plot. The percentage of phosphorylatable residues ([ST]P) were calculated for all the proteins and Low, Mid and High levels of putative phosphorylations sites were defined with arbitrary breaks (0-15%, 15-20%,20-60% ) of the percentage values, based on the quartiles of the distribution.

```{r comparison scatters ,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 4: Pairwise comparison of the % of disorder residues determined by the different methods",fig.height=8,fig.width=10 }

compDataSet <- yeastDiso[,c(2,6:9)]
phosphorylatableResidues <- numeric()
for (phosoSites in gregexpr(pattern = "[ST]P",as.character(compDataSet[,1]))){phosphorylatableResidues<-c(phosphorylatableResidues,length(phosoSites))}
compDataSet$nPhosphoRes <- phosphorylatableResidues
compDataSet[,1] <- nchar(as.character(compDataSet[,1]))
colnames(compDataSet)[1] <- "proteinLength"
compDataSet$percPhosphoRes <- (compDataSet$nPhosphoRes/compDataSet$proteinLength)*100
compDataSet$levelPhosphoRes<-cut(compDataSet$percPhosphoRes,breaks = c(0,0.45,1,10),labels = c("Low","Mid","High"))

print(summary(compDataSet$percPhosphoRes))
GGally::ggpairs(data = compDataSet,columns = c(2:5), ggplot2::aes(colour=levelPhosphoRes,alpha=0.5),xlab="% of disorder residues", ylab="% of disorder residues",columnLabels=c("Simple predictor","MobiDB-Lite predictor","Derived","DB")) +
     theme(panel.grid.minor = element_blank(),panel.grid.major = element_blank()) + theme_classic()

```
  
  
### Lenght distribution in the detection of IDRs 
  

None of the methods for estimating the disorder regions of proteins seem to be in agreement with the other methods in the percentage of disorder residues for a given protein. The correlation coefficients are low, and the ratio of putative phosphorylation sites does not have any significant impact on these calculations. Moreover, the distribution of the percentage of phosphorylatable residues appears to be completely random in all the pairwise comparison scatterplots. 
The lack of correlation in this metric for different methods does not directly imply that the methods are not identifying the same regions. In fact, all of the aminoacids classified as disordered by the MobiDB lite method, for all the proteins, were also detected by the simple method. Disparities in the lengths of the disorder stretches lead to these observed effects.  

```{r stretches of disorder ,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 5:distribution of the lenghts of disorder stretches" }

predStretchDist <- getPredDiso(yeastDiso,"lenghts")
predStretchDist <- cbind(predStretchDist,rep("Simple predictor",length(predStretchDist)))
predLiteStretchDist <- getPredLiteDiso(yeastDiso,"lenghts")
predLiteStretchDist <- cbind(predLiteStretchDist,rep("MobiDB-lite predictor",length(predLiteStretchDist)))
dbStretchDist <- cbind(dbStretchDist,rep("DB",length(dbStretchDist)))
derivedStretchDist <- cbind(derivedStretchDist,rep("Derived",length(derivedStretchDist)))

stretchData <-rbind(predStretchDist,predLiteStretchDist,dbStretchDist,derivedStretchDist)
stretchData <-as.data.frame(stretchData)
colnames(stretchData) <- c("stretchLength","method")
stretchData$method <- as.factor(stretchData$method)
stretchData$method <- factor(stretchData$method, levels = c("Simple predictor","MobiDB-lite predictor","Derived","DB"))
stretchData$stretchLength <- as.numeric(stretchData$stretchLength)




ggplot(data = stretchData,aes(x=method,y=stretchLength)) + geom_violin(aes(fill=method), alpha = 0.7,show.legend = FALSE) +
    theme_minimal() +
    geom_boxplot(width=0.05) +
    scale_fill_manual(values = c("Simple predictor"="darkorange1","MobiDB-lite predictor" = "chartreuse3","Derived"="darkgoldenrod1","DB" = "deepskyblue2")) +
    xlab("Method") + ylab("Lenght of IDR") +
    scale_y_continuous(limits = c(0,600))
```
  

```{r simple vs. lite ,echo=FALSE,message=FALSE,warning=FALSE}

percCovLiteInSimple <- numeric()
for (i in 1:nrow(yeastDiso)) {
  liteIndex<-which(yeastDiso$disorder$predictors[[i]]$method=="mobidb-lite")
  simpleIndex<-which(yeastDiso$disorder$predictors[[i]]$method=="simple")
  if (length(liteIndex)!=0) {
    matLite<-yeastDiso$disorder$predictors[[i]]$regions[[liteIndex]]
    matSimple<-yeastDiso$disorder$predictors[[i]]$regions[[simpleIndex]]
    if (class(matLite)=="matrix") {
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
      # mat<-matrix(mat[mat[,3]=="D",],ncol=3)
      litePos <-numeric()
      litePos <-apply(matLite, 1, function(x){litePos<-c(litePos,x[1]:x[2])
                                   return(litePos)})
      litePos <- as.numeric(unlist(litePos))
      #print(litePos)
      simplePos <-numeric()
      simplePos <-apply(matSimple, 1, function(x){simplePos<-c(simplePos,x[1]:x[2])
                                   return(simplePos)})
      simplePos <- as.numeric(unlist(simplePos))
      # print(simplePos)
      percCovLiteInSimple <- c(percCovLiteInSimple,(length(which(litePos %in% simplePos))/length(litePos))*100)
      #print((length(which(litePos %in% simplePos))/length(litePos))*100)
    } 
  } 
}

```


Nevertheless, inconsistencies in the measurements of the ratio of disordered amino acids between different methods do not indicate that the metric could not be used as an estimator of global disorder status in proteins. However, we should certainly  be cautious about comparing values originated from different sources. 
If the percentage of disorder residues correlates well with one or more CDK phosphorylation target properties it could be informative regardless if the estimation is highly accurate.  
  
  
# Cdk1 targets  
  
For defining the targets for Cdk1 in Saccharomyces cerevisiae, I used publicly available data published by David Morgan's group [@Ubersax2003]. In this paper, the authors used a modified version of Cdk1 that allows bulky ATP analogues to bind in the ATP binding pocket (Cdk1-as1). They have used a library of yeast strains, each expressing a unique ORF fused with GST.  In this way, a radiolabelled bulky ATP analogue, N6-(benzyl) ATP, is administered to _in vitro_ perform kinase reactions between purified Cdk1-as1·Clb2 and the lysates from 695 different strains from the library. From the 695 unique ORF-GST selected,  385 correspond to ORFs encodign proteins with two or more Cdk consensus phosphorylation sites (S/T*-P-x-K/R), 137 ORFs encoding proteins with a single Cdk consensus site and whose transcripts are cell-cycle regulated, and 183 randomly chosen ORFs.
For each reaction, they performed a step of GST tag mediated purification and they measured the levels of tagged phosphate. The authors define the measure __"P-Score"__ as the logarithm of the amount of phosphate incorporated per nanogram of protein, and they have set the treshold of P-Score > 2 for designate the Cdk1 targets.



```{r cdk1 targets summary,echo=FALSE,message=FALSE,warning=FALSE}

# _____________________________________________________________

#The row 294 cannot be mapped with the uniprot, I will remove it from CDK1targetsSacCer and yeastDisoCDK1target. Slect only the rows wuth P-score > 2 most likely targets based on the paper

CDK1targetSacCer<-subset(CDK1targetSacCer[-294,])
yeastDisoCDK1target<-yeastDiso[match(CDK1targetSacCer$Entry,yeastDiso$acc),]
CDK1targetSacCer$length <- nchar(yeastDisoCDK1target$sequence)


npredictorsCDK=0
nmobidbliteCDK=0
nsimpleCDK=0
#methods: mobidb-lite, simple
for (i in 1:nrow(yeastDisoCDK1target)) {
  if(!is.null(yeastDisoCDK1target[i,5]$predictors[[1]])){
    npredictorsCDK=npredictorsCDK+1
    }
  if( "mobidb-lite" %in% yeastDisoCDK1target[i,5]$predictors[[1]]$method){
    nmobidbliteCDK=nmobidbliteCDK+1
    }
  if( "simple" %in% yeastDisoCDK1target[i,5]$predictors[[1]]$method){
    nsimpleCDK=nsimpleCDK+1
    }  
  }


#methods: full bfactor missing_residues mobile
nderivedCDK=0
nfullCDK=0
nbfactorCDK=0
nmissing_residuesCDK=0
nmobileCDK=0

for (i in 1:nrow(yeastDisoCDK1target)) {
  if(!is.null(yeastDisoCDK1target[i,5]$derived[[1]])){
    nderivedCDK=nderivedCDK+1
  }
  if( "full" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nfullCDK=nfullCDK+1
  }
  if( "bfactor" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nbfactorCDK=nbfactorCDK+1
  }
  if( "missing_residues" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nmissing_residuesCDK=nmissing_residuesCDK+1
  }
  if( "mobile" %in% yeastDisoCDK1target[i,5]$derived[[1]]$method){
    nmobileCDK=nmobileCDK+1
  }
}
#methods: full
ndbCDK=0
for (i in 1:nrow(yeastDisoCDK1target)) {
  if(!is.null(yeastDisoCDK1target[i,5]$db[[1]])){
    ndbCDK=ndbCDK+1
    }
}


#_______________________________adding perc of disorder to CDK1targetSacCer____________________

predDisoPercCdkTargets <- c()
predStretchDist <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  mat<-yeastDisoCDK1target$disorder$predictors[[i]]$regions[[1]]
  predStretchDist <- c(predStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  #calculate the number of disoredered AAs
  nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
  predDisoPercCdkTargets <- c(predDisoPercCdkTargets,(nDiso/proteinLength)*100)
}
CDK1targetSacCer$predDisoPercCdkTargets <- predDisoPercCdkTargets
yeastDisoCDK1target$predDisoPercCdkTargets <- predDisoPercCdkTargets

#mobidb-lite for comparing with the simple
predLiteStretchDist <- c()
predLiteDisoPercCdkTargets <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  liteIndex<-which(yeastDisoCDK1target$disorder$predictors[[i]]$method=="mobidb-lite")
  if (length(liteIndex)!=0) {
    mat<-yeastDisoCDK1target$disorder$predictors[[i]]$regions[[liteIndex]]
    if (class(mat)=="matrix") {
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
      # mat<-matrix(mat[mat[,3]=="D",],ncol=3)
      predLiteStretchDist <- c(predLiteStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      #calculate the number of disoredered AAs
      nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
      predLiteDisoPercCdkTargets <- c(predLiteDisoPercCdkTargets,(nDiso/proteinLength)*100)      
    } else {predLiteDisoPercCdkTargets <- c(predLiteDisoPercCdkTargets,0)}

  } else {
    predLiteDisoPercCdkTargets <- c(predLiteDisoPercCdkTargets,NA)
  }

}

yeastDisoCDK1target$predLiteDisoPercCdkTargets <- predLiteDisoPercCdkTargets
CDK1targetSacCer$predLiteDisoPercCdkTargets <- predLiteDisoPercCdkTargets

#For the derived methods (full -> the third matrix) the anotations could be Disorder, Structure or Conflict
derivedStretchDist <- c()
derivedDisoPercCdkTargets <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  if (!is.null(yeastDisoCDK1target$disorder$derived[[i]])) {
    fullIndex<-which(yeastDisoCDK1target$disorder$derived[[i]]$method=="full")
    mat<-yeastDisoCDK1target$disorder$derived[[i]]$regions[[fullIndex]]
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
    mat<-matrix(mat[mat[,3]=="D",],ncol=3)
    derivedStretchDist <- c(derivedStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    #calculate the number of disoredered AAs
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
    derivedDisoPercCdkTargets <- c(derivedDisoPercCdkTargets,(nDiso/proteinLength)*100)
  } else {
    derivedDisoPercCdkTargets <- c(derivedDisoPercCdkTargets,NA)
  }

}
yeastDisoCDK1target$derivedDisoPercCdkTargets <- derivedDisoPercCdkTargets
CDK1targetSacCer$derivedDisoPercCdkTargets <- derivedDisoPercCdkTargets
#For the db curated assigments (full -> the only matrix) the anotations could be Disorder, Structure or Conflict
dbDisoPercCdkTargets <- c()
dbStretchDist <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  if (!is.null(yeastDisoCDK1target$disorder$db[[i]])) {
    fullIndex<-which(yeastDisoCDK1target$disorder$db[[i]]$method=="full")
    mat<-yeastDisoCDK1target$disorder$db[[i]]$regions[[fullIndex]]
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
    mat<-matrix(mat[mat[,3]=="D",],ncol=3)
    #calculate the number of disoredered AAs
    dbStretchDist <- c(dbStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
    proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
    dbDisoPercCdkTargets <- c(dbDisoPercCdkTargets,(nDiso/proteinLength)*100)
  } else {
    dbDisoPercCdkTargets <- c(dbDisoPercCdkTargets,NA)
  }
}
yeastDisoCDK1target$dbDisoPercCdkTargets <- dbDisoPercCdkTargets
CDK1targetSacCer$dbDisoPercCdkTargets <- dbDisoPercCdkTargets

CDK1targetSacCer$target<-cut(CDK1targetSacCer$`P-Score`,breaks = c(2),labels = c("Non Cdk1 target","Cdk1 target"))
CDK1targetSacCer$MW_kDa<-(CDK1targetSacCer$length*120)/1000
CDK1targetSacCer$nmol<- (CDK1targetSacCer$`Protein Level`/CDK1targetSacCer$MW_kDa)/1000
CDK1targetSacCer$nEq_STP<- CDK1targetSacCer$nmol*CDK1targetSacCer$`[ST]-P`
CDK1targetSacCer$nEq_STPXKR<- CDK1targetSacCer$nmol*CDK1targetSacCer$`[ST]-P-X-[KR]`
CDK1targetSacCer$target<-cut(CDK1targetSacCer$`P-Score`,breaks = c(-Inf,2,Inf),labels = c("Non Cdk1 target","Cdk1 target"),right = F)
CDK1targetSacCer$targetStrict<-cut(CDK1targetSacCer$`P-Score`,breaks = c(-Inf,3,Inf),labels = c("Non Cdk1 target","Cdk1 target"),right = F)
```

```{r cdkTargetTable ,echo=FALSE,message=FALSE,warning=FALSE,rows.print=20}
CDK1targetSacCer[order(CDK1targetSacCer$`P-Score`,decreasing = T),c(1,11,15,6,7,8,3,4,5)]
```
  
From the original 695 ORFs, I kept 687 which could be unequivocally to a unique Uniprot accesion. This ID will allow us to merge the disorder data obtained from the MobiDB database and the annotations extracted from the Cdk1 targets paper data.  
  
## P-Score
  
In order to understand the P-Score, I compare its value against P-score normalized by the numbers of mol proteins instead of the mass. For this calculation we consider that the average molar mass of one amino acid is 120 gr/mol:

$$\log(\frac{Phosphorylation_{<arbitrary\ units>}}{Protein Level _{<ng>} / MW _{<ng/nmol>}}) = log(\frac{Phosphorylation_{<arbitrary\ units>}}{Protein Level _{<ng>} / (length _{<amin oacids>} *\ 120 _{<ng/(nmol*amino acids)>}))})$$   
  
If we consider every consensus phosphosite as phosphorylatable, we could normalize not only by the number of moles in the reaction, but also by the number of moles of phosphosites. We could think this concept as similar to the definition of one Equivalent. For the two consensus patterns considered (S/T\*-P-x-K/R and S/T\*-P), we could calculate the the number of equivalents of a phsophosite as: 
$$nEq/mol*nmol = n° (S/T-P-x-K/R)\ or\ n°(S/T-P)*\frac{Protein Level _{<ng>}}{(length _{<amin oacids>} *\ 120 _{<ng/(nmol*amino acids)>}}$$

```{r scores ,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 6: Comparision of the dependance of the phosphorylation on the on the ammount of protein" }

scoresData <- CDK1targetSacCer[,c("Phosphorylation","P-Score","Protein Level","nmol","nEq_STP","nEq_STPXKR","target","[ST]-P","[ST]-P-X-[KR]")]
scoresData$logPhospho <- log10(CDK1targetSacCer$Phosphorylation)
scoresData$logMol <- log10(CDK1targetSacCer$nmol)
scoresData$logEq_STP <- log10(CDK1targetSacCer$nEq_STP)
scoresData$logEq_STPXR <- log10(CDK1targetSacCer$nEq_STPXKR)
scoresData$targetStrict <- CDK1targetSacCer$target<-cut(CDK1targetSacCer$`P-Score`,breaks = c(-Inf,3,Inf),labels = c("Non Cdk1 target","Cdk1 target"),right = F)

PhosVsPL<-ggplot(scoresData,aes(x=log10(`Protein Level`),y=log10(Phosphorylation)))+geom_point(aes(color=target)) + theme_linedraw() + xlab("Log10(Protein Level<ng>)") + ylab("Log10(Phosphorylation)")
PhosVsnM<-ggplot(scoresData,aes(x=log10(`nmol`),y=log10(Phosphorylation)))+geom_point(aes(color=target)) + theme_linedraw() + theme(axis.title.y = element_blank())+ xlab("Log10(nmoles)") + ylab("Log10(Phosphorylation)")
PhosVsnEqSTP<-ggplot(scoresData,aes(x=log10(`nEq_STP`),y=log10(Phosphorylation)))+geom_point(aes(color=target)) + theme_linedraw()  + xlab("Log10(nEquivalents S/T-P)") + ylab("Log10(Phosphorylation)") 
PhosVsnEqSTPXKR<-ggplot(scoresData,aes(x=log10(`nEq_STPXKR`),y=log10(Phosphorylation)))+geom_point(aes(color=target)) + theme_linedraw() + theme(axis.title.y = element_blank()) + xlab("Log10(nEquivalents S/T-P-x-K/R)") + ylab("Log10(Phosphorylation)")

ggarrange(PhosVsPL,PhosVsnM,PhosVsnEqSTP,PhosVsnEqSTPXKR,common.legend = TRUE, legend = "bottom")
```


```{r cdkTarget ,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 7:",fig.height=10}

l_pl_nm<-ggplot(scoresData,aes(x=log10(`Protein Level`),y=log10(`nmol`)))+geom_point(aes(color=target)) + theme_linedraw() + theme(axis.title.x = element_blank()) +  xlab("Log10(Protein Level <ng>)") + ylab("Log10(nMoles)")

l_pl_nES<-ggplot(scoresData,aes(x=log10(`Protein Level`),y=log10(`nEq_STP`)))+geom_point(aes(color=target)) + theme_linedraw() + theme(axis.title.x = element_blank()) +  xlab("Log10(Protein Level <ng>)") + ylab("Log10(nEquivalents S/T-P)")
l_pl_nEF<-ggplot(scoresData,aes(x=log10(`Protein Level`),y=log10(`nEq_STPXKR`)))+geom_point(aes(color=target)) + theme_linedraw() + xlab("Log10(Protein Level <ng>)") + ylab("Log10(nEquivalents S/T-P-x-K/R)")




pl_nm<-ggplot(scoresData,aes(x=`Protein Level`,y=`nmol`))+geom_point(aes(color=target)) + theme_linedraw()+ theme(axis.title.x = element_blank())  +  xlab("Protein Level <ng>") + ylab("nMoles")

pl_nES<-ggplot(scoresData,aes(x=`Protein Level`,y=`nEq_STP`))+geom_point(aes(color=target)) + theme_linedraw() + theme(axis.title.x =  element_blank()) +  xlab("Protein Level <ng>") + ylab("nEquivalents S/T-P")
pl_nEF<-ggplot(scoresData,aes(x=`Protein Level`,y=`nEq_STPXKR`))+geom_point(aes(color=target)) + theme_linedraw() + xlab("Protein Level <ng>") + ylab("nEquivalents S/T-P-x-K/R")

ggarrange(l_pl_nm,pl_nm,l_pl_nES,pl_nES,l_pl_nEF,pl_nEF,nrow = 3, ncol = 2,common.legend = TRUE, legend = "bottom")
```

```{r  ,echo=FALSE,message=FALSE,warning=FALSE, fig.cap="Figure 8:",fig.height=10}


compDataSet$levelPhosphoRes<-cut(compDataSet$percPhosphoRes,breaks = c(0,0.45,1,10),labels = c("Low","Mid","High"))

ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`,y=`[ST]-P-X-[KR]`/length))+geom_point(aes(color=target))+geom_smooth(method=lm, se=FALSE)


```
ggplot(CDK1targetSacCer)+geom_density(aes(x = predDisoPercCdkTargets,fill = target),alpha=.5)
ggplot(CDK1targetSacCer)+geom_density(aes(x = predLiteDisoPercCdkTargets,fill = target),alpha=.5)
ggplot(CDK1targetSacCer)+geom_density(aes(x = length,fill = target),alpha=.5)

ggplot(CDK1targetSacCer)+geom_histogram(aes(x = `[ST]-P`/length,fill = target),alpha=.5)
ggplot(CDK1targetSacCer)+geom_density(aes(x = `[ST]-P`/length,fill = target),alpha=.5)
ggplot(CDK1targetSacCer)+geom_density(aes(x = `[ST]-P-X-[KR]`/length,fill = target),alpha=.5)

ggplot(CDK1targetSacCer)+geom_density(aes(x = log10(Phosphorylation/`nEq_STP`),fill = target),alpha=.5,bw=0.5)

ggplot(subset(CDK1targetSacCer,`P-Score`>2),aes(x=log10(`nmol`),y=log10(Phosphorylation)))+geom_point(aes(color=length))+scale_color_continuous(low = "green",high = "red")



ggplot(subset(CDK1targetSacCer,`P-Score`>2),aes(x=length*0.005,y=`[ST]-P-X-[KR]`))+geom_point(aes(color=length))+scale_color_continuous(low = "green",high = "red")



ggplot(CDK1targetSacCer)+geom_density(aes(x = log(nEq_STPXKR),fill = target),alpha=.5,bw=0.5)





ggplot(subset(CDK1targetSacCer,`P-Score`>2))+geom_histogram(aes(x=`[ST]-P`/length))
ggplot(CDK1targetSacCer)+geom_histogram(aes(x=`[ST]-P-X-[KR]`/length))
ggplot(CDK1targetSacCer)+geom_histogram(aes(x=`[ST]-P-X-[KR]`))
ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`/length,y=predDisoPercCdkTargets))+geom_point(aes(color=`[ST]-P-X-[KR]`))+scale_color_continuous(low = "green",high = "red")
ggplot(CDK1targetSacCer)+geom_histogram(aes(x=`[ST]-P-X-[KR]`))
ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`/length,y=predDisoPercCdkTargets))+geom_point(aes(color=`[ST]-P`))+scale_color_continuous(low = "green",high = "red")
ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`/length,y=predLiteDisoPercCdkTargets))+geom_point(aes(color=`[ST]-P-X-[KR]`/length))+scale_color_continuous(low = "green",high = "red")
ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`/length,y=predLiteDisoPercCdkTargets))+geom_point(aes(color=`[ST]-P`/length))+scale_color_continuous(low = "green",high = "red")
ggplot(subset(CDK1targetSacCer,`P-Score`>2),aes(y=`P-Score`/length,x=predLiteDisoPercCdkTargets))+geom_point()



ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`/length,y=`[ST]-P-X-[KR]`/length))+geom_point()+geom_smooth(method=lm, se=FALSE)
ggplot(subset(CDK1targetSacCer,`P-Score`>0),aes(x=`P-Score`/length,y=`[ST]-P`/length))+geom_point()+geom_smooth(method=lm, se=FALSE)

ggplot(subset(CDK1targetSacCer,`P-Score`>0))+geom_histogram(aes(x=length))
```
P-score does not consider the size nor the number of consensus phospho sites for Cdk1. P-Score = log(Phosphorylation<arbitrary units>/ Protein level <ng>)

For correcting for protein lenght we can do P-Score Mol = log(Phosphorylation<arbitrary units>/ number of protein umols) = log(Phosphorylation<arbitrary units>/ (Protein Level <ng> / (length <AAs>)*120 <g mol/AAs>))

Correcting for number of moles in the reaction or for number of Eq of [ST]-P sites or [ST]-P-X-[KR] doesn't change much, probably due to the fact that this correction is linear and the final effect in the logarithm scale of the Score is not relevant  

```{r explore,echo=FALSE,message=FALSE,warning=FALSE}

predDisoPercAll <- c()
for (i in 1:nrow(yeastDiso)) {
  mat<-yeastDiso$disorder$predictors[[i]]$regions[[1]]
  #calculate the number of disoredered AAs
  nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  proteinLength <- nchar(yeastDiso$sequence[i])
  predDisoPercAll <- c(predDisoPercAll,(nDiso/proteinLength)*100)
}





predDisoPercCDK1target <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  mat<-yeastDisoCDK1target$disorder$predictors[[i]]$regions[[1]]
  #calculate the number of disoredered AAs
  nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
  proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
  predDisoPercCDK1target <- c(predDisoPercCDK1target,(nDiso/proteinLength)*100)
}



CDK1targetSacCer$percDiso_predicted <- yeastDisoCDK1target$predDisoPerc

predLiteStretchDist <- c()
predLiteDisoPercAll <- c()
for (i in 1:nrow(yeastDisoCDK1target)) {
  liteIndex<-which(yeastDisoCDK1target$disorder$predictors[[i]]$method=="mobidb-lite")
  if (length(liteIndex)!=0) {
    mat<-yeastDisoCDK1target$disorder$predictors[[i]]$regions[[liteIndex]]
    if (class(mat)=="matrix") {
#getting only the disordered rows. Is really important to reconvert to a matrix of ncol=3 just in case I index only one row and I get a vector. the the subindex mat[,2] will throw incorrect number of dimensions
      # mat<-matrix(mat[mat[,3]=="D",],ncol=3)
      predLiteStretchDist <- c(predLiteStretchDist,as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      #calculate the number of disoredered AAs
      nDiso<-sum(as.numeric(mat[,2])-as.numeric(mat[,1])+1)
      proteinLength <- nchar(yeastDisoCDK1target$sequence[i])
      predLiteDisoPercAll <- c(predLiteDisoPercAll,(nDiso/proteinLength)*100)      
    } else {predLiteDisoPercAll <- c(predLiteDisoPercAll,0)}

  } else {
    predLiteDisoPercAll <- c(predLiteDisoPercAll,NA)
  }

}
yeastDisoCDK1target$predLiteDisoPercAll <- predLiteDisoPercAll

CDK1targetSacCer$predLiteDisoPercAll <- yeastDisoCDK1target$predLiteDisoPercAll
```

```{r agreements disorder vs phosposites ,echo=FALSE,message=FALSE,warning=FALSE}



disorderedRegions <- getPredDiso(df = yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2),],"indices")
TPphosphoSites <- gregexpr("[ST]P",yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2),]$sequence)

stratContingencyArray <- array(dim = c(2,2,nrow(yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2),])))
for (i in 1:nrow(yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2),])) {
  
  indexProt <- 1:nchar(yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2),]$sequence[[i]])
  indexDiso <- disorderedRegions[[i]]
  indexOrd <- setdiff(indexProt,indexDiso)
  indexPhospho <- as.numeric(TPphosphoSites[[i]])
  indexNonPhospho <- setdiff(indexProt,indexPhospho)
  
  ndp <- length(which(indexPhospho %in% indexDiso))
  nop <- length(which(indexPhospho %in% indexOrd))
  ndnp <- length(which(indexNonPhospho %in% indexDiso))
  nonp<- length(which(indexNonPhospho %in% indexOrd))
  stratContingencyArray[1,1,i]<-ndp
  stratContingencyArray[1,2,i]<-nop
  stratContingencyArray[2,1,i]<-ndnp
  stratContingencyArray[2,2,i]<-nonp
  
}
woolf_test(stratContingencyArray)
apply(stratContingencyArray, 3,function(x){
     ft<-fisher.test(x)
     return(ft$p.value)
     })




liteDisorderedRegions <- getPredLiteDiso(df = yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2 &!is.na(CDK1targetSacCer$predLiteDisoPercCdkTargets)),],"indices")
liteTPphosphoSites <- gregexpr("[ST]P",yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2 &!is.na(CDK1targetSacCer$predLiteDisoPercCdkTargets)),]$sequence)

liteStratContingencyArray <- array(dim = c(2,2,nrow(yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2 &!is.na(CDK1targetSacCer$predLiteDisoPercCdkTargets)),])))
for (i in 1:nrow(yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2 &!is.na(CDK1targetSacCer$predLiteDisoPercCdkTargets)),])) {
  
  indexProtLite <- 1:nchar(yeastDisoCDK1target[which(CDK1targetSacCer$`P-Score`>=2 &!is.na(CDK1targetSacCer$predLiteDisoPercCdkTargets)),]$sequence[[i]])
  indexDisoLite <- liteDisorderedRegions[[i]]
  indexOrdLite <- setdiff(indexProtLite,indexDisoLite)
  indexPhosphoLite <- as.numeric(liteTPphosphoSites[[i]])
  indexNonPhosphoLite <- setdiff(indexProtLite,indexPhosphoLite)
  
  ndpLite <- length(which(indexPhosphoLite %in% indexDisoLite))
  nopLite <- length(which(indexPhosphoLite %in% indexOrdLite))
  ndnpLite <- length(which(indexNonPhosphoLite %in% indexDisoLite))
  nonpLite<- length(which(indexNonPhosphoLite %in% indexOrdLite))
  liteStratContingencyArray[1,1,i]<-ndpLite
  liteStratContingencyArray[1,2,i]<-nopLite
  liteStratContingencyArray[2,1,i]<-ndnpLite
  liteStratContingencyArray[2,2,i]<-nonpLite
  
}




woolf_test(liteStratContingencyArray)
ors <- apply(liteStratContingencyArray, 3,function(x){
     ft<-fisher.test(x)
     return(ft$estimate)
     })

logors <- log10(ors)
logors[is.infinite(logors) & logors > 0] <- 2
logors[is.infinite(logors) & logors < 0] <- -2

ggplot()+geom_bar(aes(x=1:length(logors), y=logors),stat="identity")+ylim(c(-2,2))


getAAfrequency <- function(sequences,regions=NULL,complement=FALSE){
  
  if (!is.null(regions)) {
    if (complement) {
      regionIndex <- lapply(liteDisorderedRegions, function(x){return(-as.integer(x))})
    } else {
      regionIndex <- regions
      }
  } else {
    regionIndex <- rep(TRUE,length(sequences))
    }
  aaSummary <- 0
  for (i in 1:length(sequences)) {
    seqVector<-strsplit(sequences[i],"")[[1]][regionIndex[[i]]]
    # print(seqVector)
    aaSummary <- summary(factor(seqVector,levels = c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y"))) + aaSummary
    # print(aaSummary)
    } 
  return(100*(aaSummary/sum(aaSummary)))
}



```
  
  
# Bibliography

